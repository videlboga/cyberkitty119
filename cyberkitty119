#!/usr/bin/env python3

import os
import logging
import asyncio
import subprocess
import whisper
import json
from pathlib import Path
from dotenv import load_dotenv
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import (
    Application, ApplicationBuilder, CommandHandler, MessageHandler, 
    CallbackQueryHandler, ContextTypes, filters
)
import aiohttp
import sys

# Загрузка переменных окружения
load_dotenv()

# Получаем настройки из .env файла
BOT_TOKEN = os.getenv('TELEGRAM_BOT_TOKEN')
TELETHON_WORKER_CHAT_ID = int(os.getenv('TELETHON_WORKER_CHAT_ID', '0'))
OPENAI_API_KEY = os.getenv('OPENAI_API_KEY', '')
OPENROUTER_API_KEY = os.getenv('OPENROUTER_API_KEY', '')
OPENROUTER_MODEL = os.getenv('OPENROUTER_MODEL', 'anthropic/claude-3-opus:beta')
DEEPINFRA_API_KEY = os.getenv('DEEPINFRA_API_KEY', '')

# Пути для файлов
BASE_DIR = Path(__file__).resolve().parent
VIDEOS_DIR = BASE_DIR / "videos"
AUDIO_DIR = BASE_DIR / "audio"
TRANSCRIPTIONS_DIR = BASE_DIR / "transcriptions"

# Создаем директории, если они не существуют
VIDEOS_DIR.mkdir(exist_ok=True)
AUDIO_DIR.mkdir(exist_ok=True)
TRANSCRIPTIONS_DIR.mkdir(exist_ok=True)

# Настройка логирования
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(),
        logging.FileHandler("cyberkitty119.log")
    ]
)
logger = logging.getLogger(__name__)

# Константы
MAX_MESSAGE_LENGTH = 4096  # Максимальная длина сообщения в Telegram

# Глобальный словарь для хранения транскрипций пользователей
user_transcriptions = {}

# Функции для работы с видео и аудио
async def extract_audio_from_video(video_path, audio_path):
    """Извлекает аудио из видео с использованием ffmpeg в фоновом режиме."""
    try:
        # Создаем директорию для аудио, если она не существует
        audio_path.parent.mkdir(exist_ok=True)
        
        logger.info(f"Извлечение аудио из видео: {video_path} в {audio_path}")
        
        # Используем ffmpeg в фоновом режиме
        logger.info("Запускаю ffmpeg в фоновом режиме")
        
        # Формируем команду для запуска в фоне
        cmd = f'ffmpeg -i "{str(video_path)}" -vn -acodec pcm_s16le -ar 44100 -ac 2 -y "{str(audio_path)}" </dev/null >/dev/null 2>&1 &'
        
        # Запускаем ffmpeg в фоне
        os.system(cmd)
        
        # Ждем некоторое время, чтобы процесс запустился
        await asyncio.sleep(0.5)
        
        # Ждем некоторое разумное время для завершения процесса
        max_wait_time = 60  # максимальное время ожидания в секундах
        check_interval = 0.5  # интервал проверки в секундах
        
        elapsed_time = 0
        while elapsed_time < max_wait_time:
            if audio_path.exists() and audio_path.stat().st_size > 0:
                # Файл создан и не пустой
                logger.info(f"✅ Аудио успешно извлечено из видео, размер: {audio_path.stat().st_size} байт")
                return True
            
            await asyncio.sleep(check_interval)
            elapsed_time += check_interval
            
            if elapsed_time % 5 == 0:
                logger.debug(f"Ожидание создания файла: {elapsed_time} секунд...")
        
        # Если мы здесь, значит время ожидания истекло
        logger.error(f"❌ Время ожидания создания аудиофайла истекло ({max_wait_time} секунд)")
        return False
    
    except Exception as e:
        logger.error(f"❌ Ошибка при извлечении аудио из видео: {e}")
        import traceback
        logger.error(traceback.format_exc())
        return False

async def transcribe_audio(audio_path, model_name="base"):
    """Транскрибирует аудио с помощью Whisper."""
    try:
        logger.info(f"Загрузка модели Whisper '{model_name}'...")
        model = whisper.load_model(model_name)
        
        logger.info(f"Транскрибация аудиофайла: {audio_path}")
        result = model.transcribe(str(audio_path))
        
        logger.info(f"Транскрипция завершена, получено {len(result['text'])} символов")
        return result["text"]
        
    except Exception as e:
        logger.error(f"Ошибка при транскрибации аудио: {e}")
        return None

async def format_transcript_with_llm(raw_transcript: str) -> str:
    """Форматирует транскрипцию с использованием языковой модели."""
    try:
        # Проверяем, не пустая ли транскрипция
        if not raw_transcript or len(raw_transcript.strip()) < 10:
            logger.warning("Транскрипция слишком короткая для форматирования")
            return raw_transcript
            
        # Используем OpenRouter API для форматирования
        if OPENROUTER_API_KEY:
            formatted = await format_transcript_with_openrouter(raw_transcript)
            if formatted:
                return formatted
        
        # Формальное форматирование, если не удалось использовать LLM
        return raw_transcript
            
    except Exception as e:
        logger.error(f"Ошибка при форматировании транскрипции: {e}")
        return raw_transcript

async def format_transcript_with_openrouter(raw_transcript: str) -> str:
    """Форматирует сырую транскрипцию с помощью OpenRouter API."""
    if not OPENROUTER_API_KEY or not OPENROUTER_MODEL:
        logger.warning("OpenRouter API ключ или модель не настроены")
        return None
        
    try:
        logger.info(f"Форматирование транскрипции с помощью OpenRouter API, модель: {OPENROUTER_MODEL}")
        
        # Создаем промпт для модели
        system_prompt = """Ты помощник по форматированию сырых транскрипций. 
        Твоя задача - превратить сырую необработанную транскрипцию аудио в читабельный текст. 
        Исправь ошибки, добавь пунктуацию, разбей на предложения и абзацы, 
        где это уместно. Не добавляй собственные мысли или содержание, 
        которого нет в исходном тексте."""
        
        user_prompt = f"""Вот сырая транскрипция аудио. Пожалуйста, отформатируй ее в читабельный текст:

{raw_transcript}

Правила форматирования:
1. Исправь ошибки распознавания, где они очевидны
2. Добавь правильную пунктуацию
3. Разбей текст на логические предложения и абзацы
4. Удали повторы и заполнители речи (эээ, ммм, и т.д.)
5. Возвращай только отформатированный текст без дополнительных комментариев"""
        
        # Формируем запрос к API
        headers = {
            "Authorization": f"Bearer {OPENROUTER_API_KEY}",
            "Content-Type": "application/json"
        }
        
        payload = {
            "model": OPENROUTER_MODEL,
            "messages": [
                {"role": "system", "content": system_prompt},
                {"role": "user", "content": user_prompt}
            ],
            "temperature": 0.1,  # Низкая температура для более детерминированных результатов
            "max_tokens": 4096
        }
        
        # Отправляем запрос
        async with aiohttp.ClientSession() as session:
            async with session.post(
            "https://openrouter.ai/api/v1/chat/completions",
            headers=headers,
            json=payload
            ) as response:
                if response.status == 200:
                    data = await response.json()
                    formatted_text = data["choices"][0]["message"]["content"]
                    logger.info("Транскрипция успешно отформатирована с помощью OpenRouter API")
                    return formatted_text
                else:
                    error_text = await response.text()
                    logger.error(f"Ошибка от OpenRouter API: {response.status}, {error_text}")
                    return None
        
    except Exception as e:
        logger.error(f"Ошибка при форматировании транскрипции через OpenRouter API: {e}")
        import traceback
        logger.error(traceback.format_exc())
        return None

async def process_video_file(video_path, chat_id, message_id, context, status_message=None):
    """Обрабатывает видео из файла, извлекает аудио и выполняет транскрибацию.
    Эта версия не требует объекта Update и может быть использована напрямую с файлами."""
    
    try:
        # Пути к файлам
        audio_path = AUDIO_DIR / f"telegram_video_{message_id}.wav"
        
        # Проверяем наличие видео
        if not video_path.exists():
            if status_message:
                await status_message.edit_text(
                    "Мяу! Видеофайл не найден. Возможно, возникла ошибка при скачивании. *грустно машет хвостом*"
                )
            else:
                await context.bot.send_message(
                    chat_id=chat_id,
                    text="Мяу! Видеофайл не найден. Возможно, возникла ошибка при скачивании. *грустно машет хвостом*"
                )
                return
        
        # Создаем статусное сообщение, если его еще нет
        if not status_message:
            status_message = await context.bot.send_message(
                chat_id=chat_id,
                text="Мур-мур! Начинаю обработку видео... *сосредоточенно смотрит на экран*"
            )
        
        # Извлекаем аудио из видео
        await status_message.edit_text(
            "Извлечение аудио из видео... *нетерпеливо перебирает лапками*"
        )
        
        audio_extracted = await extract_audio_from_video(video_path, audio_path)
        if not audio_extracted:
            await status_message.edit_text(
                "Не удалось извлечь аудио из видео. *грустно вздыхает*"
            )
        return
    
        # Транскрибируем аудио
        await status_message.edit_text(
            "Аудио извлечено! Теперь транскрибирую... *возбужденно виляет хвостом*"
        )
        
        raw_transcript = await transcribe_audio(audio_path)
        if not raw_transcript:
            await status_message.edit_text(
                "Не удалось выполнить транскрипцию аудио. *расстроенно мяукает*"
            )
            return
        
        # Форматируем транскрипцию
        await status_message.edit_text(
            "Транскрипция получена! Привожу текст в читаемый вид... *деловито стучит по клавиатуре*"
        )
        
        formatted_transcript = await format_transcript_with_llm(raw_transcript)
        
        # Создаем файлы с транскрипциями
        transcript_path = TRANSCRIPTIONS_DIR / f"telegram_video_{message_id}.txt"
        raw_transcript_path = TRANSCRIPTIONS_DIR / f"telegram_video_{message_id}_raw.txt"
        
        with open(transcript_path, "w", encoding="utf-8") as f:
            f.write(formatted_transcript)
            
        with open(raw_transcript_path, "w", encoding="utf-8") as f:
            f.write(raw_transcript)
        
        # Сохраняем транскрипции для пользователя
        user_transcriptions[chat_id] = {
            'raw': raw_transcript,
            'formatted': formatted_transcript,
            'path': str(transcript_path),
            'raw_path': str(raw_transcript_path),
            'timestamp': asyncio.get_event_loop().time()
        }
        
        # Отправляем результаты пользователю
        if len(formatted_transcript) > MAX_MESSAGE_LENGTH:\            # Если транскрипция слишком длинная, отправляем файлом\            await status_message.edit_text(\                "Готово! Транскрипция получилась длинной, отправляю файлом... *довольно мурлычет*"\            )\            \            # Отправляем файл с транскрипцией\            with open(transcript_path, "rb") as file:\                await context.bot.send_document(\                    chat_id=chat_id,\                    document=file,\                    filename=f"Транскрипция видео {message_id}.txt",\                    caption="Вот транскрипция вашего видео! *выгибает спину от гордости*"\                )\        else:\            # Если транскрипция не слишком длинная, отправляем текстом\            await status_message.edit_text(\                f"Готово! Вот транскрипция вашего видео:\n\n{formatted_transcript}\n\n*гордо машет хвостом*"\            )
        # Отправляем файл с сырой транскрипцией (опционально)
        with open(raw_transcript_path, "rb") as file:
            await context.bot.send_document(
                chat_id=chat_id,
                document=file,
                filename=f"Сырая транскрипция видео {message_id}.txt",
                caption="А вот и необработанная версия транскрипции, если вам интересно *хитро подмигивает*"
            )
        
        logger.info(f"Транскрипция видео успешно завершена, файлы: {transcript_path}, {raw_transcript_path}")
        return transcript_path, raw_transcript_path
        
    except Exception as e:
        logger.error(f"Ошибка при обработке видео: {e}")
        import traceback
        logger.error(traceback.format_exc())
        
        if status_message:
            await status_message.edit_text(
                f"Произошла ошибка при обработке видео: {e}. *виновато опускает уши*"
            )
        return None, None

async def process_video(chat_id, message_id, update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Обрабатывает видео, извлекает аудио и выполняет транскрибацию."""
    user_id = update.effective_user.id
    
    try:
        # Пути к файлам
        video_path = VIDEOS_DIR / f"telegram_video_{message_id}.mp4"
        audio_path = AUDIO_DIR / f"telegram_video_{message_id}.wav"
        
        # Проверяем наличие видео
        if not video_path.exists():
            await update.message.reply_text(
                "Мяу! Видеофайл не найден. Возможно, возникла ошибка при скачивании. *грустно машет хвостом*"
            )
            return
        
        # Отправляем сообщение о начале обработки
        status_message = await update.message.reply_text(
            "Мур-мур! Начинаю обработку видео... *сосредоточенно смотрит на экран*"
        )
        
        # Извлекаем аудио из видео
        await status_message.edit_text(
            "Извлечение аудио из видео... *нетерпеливо перебирает лапками*"
        )
        
        audio_extracted = await extract_audio_from_video(video_path, audio_path)
        if not audio_extracted:
            await status_message.edit_text(
                "Не удалось извлечь аудио из видео. *грустно вздыхает*"
            )
            return
        
        # Транскрибируем аудио
        await status_message.edit_text(
            "Аудио извлечено! Теперь транскрибирую... *возбужденно виляет хвостом*"
        )
        
        raw_transcript = await transcribe_audio(audio_path)
        if not raw_transcript:
            await status_message.edit_text(
                "Не удалось выполнить транскрипцию аудио. *расстроенно мяукает*"
            )
            return
        
        # Форматируем транскрипцию
        await status_message.edit_text(
            "Транскрипция получена! Привожу текст в читаемый вид... *деловито стучит по клавиатуре*"
        )
        
        formatted_transcript = await format_transcript_with_llm(raw_transcript)
        
        # Создаем файлы с транскрипциями
        transcript_path = TRANSCRIPTIONS_DIR / f"telegram_video_{message_id}.txt"
        raw_transcript_path = TRANSCRIPTIONS_DIR / f"telegram_video_{message_id}_raw.txt"
        
        with open(transcript_path, "w", encoding="utf-8") as f:
            f.write(formatted_transcript)
        
        with open(raw_transcript_path, "w", encoding="utf-8") as f:
            f.write(raw_transcript)
        
        # Сохраняем транскрипции для пользователя
            user_transcriptions[user_id] = {
            'raw': raw_transcript,
                'formatted': formatted_transcript,
                'path': str(transcript_path),
                'raw_path': str(raw_transcript_path),
                'timestamp': asyncio.get_event_loop().time()
            }
        
        # Отправляем результаты пользователю
        if len(formatted_transcript) > MAX_MESSAGE_LENGTH:
            # Если транскрипция слишком длинная, отправляем файлом
            await status_message.edit_text(
                "Готово! Транскрипция получилась длинной, отправляю файлом... *довольно мурлычет*"
            )
            
            with open(transcript_path, "rb") as f:
                await context.bot.send_document(
                chat_id=chat_id,
                    document=f,
                    filename=f"transcript_{message_id}.txt",
                    caption="Вот ваша транскрипция! *гордо поднимает хвост*"
            )
        else:
            # Иначе отправляем текстом
            await status_message.edit_text(
                f"Готово! Вот транскрипция видео:\n\n{formatted_transcript}\n\n"
                f"*довольно мурлычет*"
            )
            
        # Добавляем кнопку для получения исходной транскрипции
        keyboard = [
            [InlineKeyboardButton("Показать сырую транскрипцию", callback_data=f"raw_{message_id}")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await update.message.reply_text(
            "Вы можете получить необработанную версию транскрипции, нажав на кнопку ниже:",
            reply_markup=reply_markup
        )
        
    except Exception as e:
        logger.error(f"Ошибка при обработке видео: {e}")
        await update.message.reply_text(
            f"Произошла ошибка при обработке видео: {str(e)} *испуганно прячется*"
        )

# Команды бота
async def start_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Обрабатывает команду /start."""
    await update.message.reply_text(
        "Мур! Привет! Я КиберКотик - бот для транскрибации видео и аудио! *виляет хвостиком*\n\n"
        "Отправь мне видео или аудио файл, и я создам текстовую расшифровку! "
        "Также ты можешь отправить ссылку на YouTube или Google Drive."
    )

async def help_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Обрабатывает команду /help."""
    await update.message.reply_text(
        "Мур-мур! Вот что я умею: *игриво машет лапкой*\n\n"
        "1. Транскрибировать видео, которые ты отправишь мне напрямую\n"
        "2. Транскрибировать видео из пересланных сообщений\n"
        "3. Скачивать и транскрибировать видео по ссылкам с YouTube или Google Drive\n\n"
        "Просто отправь мне видео или ссылку, и я займусь расшифровкой! *подмигивает*"
    )

async def status_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Показывает статус телетон-воркера и проверяет его работоспособность."""
    session_file = Path("telethon_worker.session")
    
    if session_file.exists():
        session_status = "✅ Файл сессии Telethon существует"
    else:
        session_status = "❌ Файл сессии Telethon отсутствует. Выполните авторизацию с помощью telethon_auth.py"
    
        await update.message.reply_text(
        f"Статус системы:\n\n"
        f"{session_status}\n"
        f"🆔 ID телетон-воркера: {TELETHON_WORKER_CHAT_ID}\n\n"
        f"Для работы с видео необходимо:\n"
        f"1. Авторизовать Telethon клиент через telethon_auth.py\n"
        f"2. Запустить телетон-воркер (telethon_worker.py)\n"
        f"3. Убедиться, что BOT_ID в .env соответствует имени пользователя бота"
    )

async def raw_transcript_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Обрабатывает команду /rawtranscript для получения необработанной транскрипции."""
    user_id = update.effective_user.id
    
    if user_id not in user_transcriptions or 'raw' not in user_transcriptions[user_id]:
        await update.message.reply_text(
            "У вас пока нет сохраненных транскрипций. *растерянно оглядывается*"
        )
        return
        
    transcript_data = user_transcriptions[user_id]
    raw_transcript = transcript_data['raw']
    
    if len(raw_transcript) > MAX_MESSAGE_LENGTH:
        # Если транскрипция слишком длинная, отправляем файлом
        raw_file_path = transcript_data.get('raw_path')
        
        if raw_file_path and Path(raw_file_path).exists():
            with open(raw_file_path, "rb") as f:
                await context.bot.send_document(
                    chat_id=update.effective_chat.id,
                    document=f,
                    filename=f"raw_transcript_{user_id}.txt",
                    caption="Вот необработанная транскрипция вашего последнего видео! *деловито машет хвостом*"
                )
            else:
            await update.message.reply_text(
                "Не могу найти файл с сырой транскрипцией. *растерянно смотрит*"
            )
    else:
        # Иначе отправляем текстом
        await update.message.reply_text(
            f"Вот необработанная транскрипция вашего последнего видео:\n\n{raw_transcript}\n\n"
            f"*деловито кивает*"
        )

# Обработчики для интерактивных элементов
async def button_callback(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Обрабатывает нажатия на кнопки в сообщениях."""
    query = update.callback_query
    await query.answer()
    
    if query.data.startswith("raw_"):
        try:
            message_id = query.data.split("_")[1]
            raw_transcript_path = TRANSCRIPTIONS_DIR / f"telegram_video_{message_id}_raw.txt"
            
            if not raw_transcript_path.exists():
                await query.message.reply_text(
                    "Не могу найти сырую транскрипцию для этого видео. *растерянно смотрит*"
                )
                        return
                
            with open(raw_transcript_path, "r", encoding="utf-8") as f:
                raw_transcript = f.read()
                
            if len(raw_transcript) > MAX_MESSAGE_LENGTH:
                # Если транскрипция слишком длинная, отправляем файлом
                with open(raw_transcript_path, "rb") as f:
                    await context.bot.send_document(
                        chat_id=query.message.chat_id,
                        document=f,
                        filename=f"raw_transcript_{message_id}.txt",
                        caption="Вот необработанная транскрипция этого видео! *деловито машет хвостом*"
                    )
                else:
                # Иначе отправляем текстом
                await query.message.reply_text(
                    f"Вот необработанная транскрипция для этого видео:\n\n{raw_transcript}\n\n"
                    f"*деловито кивает*"
                )
                
        except Exception as e:
            logger.error(f"Ошибка при обработке кнопки raw transcript: {e}")
            await query.message.reply_text(
                "Произошла ошибка при получении сырой транскрипции. *смущенно прячет мордочку*"
            )

# Обработчик для сообщений
async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Обработчик для всех типов сообщений."""
    user_id = update.effective_user.id
    chat_id = update.effective_chat.id
    message_id = update.message.message_id
    
    # Логируем сообщение
    logger.info(f"Получено сообщение от пользователя {user_id}")
    
    # Проверяем сообщения от воркера (уведомления о скачивании)
    if update.message.text and "#video_downloaded_" in update.message.text:
        try:
            # Извлекаем chat_id и message_id из сообщения
            parts = update.message.text.split('_')
            if len(parts) >= 4:
                original_chat_id = int(parts[2])
                original_message_id = int(parts[3])
                
                logger.info(f"Получено уведомление о скачивании видео: chat_id={original_chat_id}, message_id={original_message_id}")
                
                # Создаем объект исходного сообщения для обработки
                video_path = VIDEOS_DIR / f"telegram_video_{original_message_id}.mp4"
                                    
                                    if video_path.exists() and video_path.stat().st_size > 0:
                    logger.info(f"Видео найдено: {video_path}, начинаю обработку")
                    
                    # Отправляем пользователю уведомление о начале обработки
                    status_message = await context.bot.send_message(
                        chat_id=original_chat_id,
                        text="Видео успешно скачано! Начинаю обработку... *радостно мурчит*"
                    )
                    
                    # Для сообщений от Pyrogram worker не создаем имитацию исходного сообщения,
                    # а просто передаем необходимые параметры для обработки
                    try:
                        # Обрабатываем видео напрямую, без использования mock_update
                        await process_video_file(video_path, original_chat_id, original_message_id, context, status_message=status_message)
                    except Exception as process_error:
                        logger.error(f"Ошибка при обработке видео: {process_error}")
                        # Отправляем сообщение об ошибке
                        await context.bot.send_message(
                            chat_id=original_chat_id,
                            text=f"Произошла ошибка при обработке видео: {process_error}. *виновато опускает уши*"
                        )
                                        else:
                    logger.error(f"Видео не найдено или пустое: {video_path}")
                    await context.bot.send_message(
                        chat_id=original_chat_id,
                        text="Не удалось найти скачанное видео. *растерянно оглядывается*"
                    )
                            except Exception as e:
            logger.error(f"Ошибка при обработке уведомления от воркера: {e}")
            import traceback
            logger.error(traceback.format_exc())
    
    # Проверяем наличие видео в сообщении
    elif update.message.video:
        logger.info(f"Получено видео от пользователя {user_id}")
        
        # Отправляем сообщение о начале загрузки
        status_message = await update.message.reply_text(
            "Мяу! Вижу видео! Скачиваю его... *возбужденно виляет хвостом*"
        )
        
        video = update.message.video
        
        try:
            # Пытаемся скачать видео напрямую
            video_file = await context.bot.get_file(video.file_id)
            
            # Создаем директорию, если не существует
            video_path = VIDEOS_DIR / f"telegram_video_{message_id}.mp4"
            video_path.parent.mkdir(exist_ok=True)
            
            # Скачиваем видео
            await video_file.download_to_drive(custom_path=video_path)
            
            # Проверяем, что файл существует и не пустой
            if video_path.exists() and video_path.stat().st_size > 0:
                logger.info(f"Видео успешно загружено: {video_path} (размер: {video_path.stat().st_size} байт)")
                
                # Обновляем статус
                await status_message.edit_text(
                    "Видео успешно загружено! Начинаю обработку... *радостно мурчит*"
                )
                
                # Обрабатываем видео
                await process_video(chat_id, message_id, update, context)
        else:
                logger.error(f"Ошибка при скачивании видео: файл не существует или пустой")
                await status_message.edit_text(
                    "Не удалось скачать видео. Пожалуйста, попробуйте снова. *печально опускает ушки*"
                )
            
    except Exception as e:
            logger.error(f"Ошибка при скачивании видео: {e}")
            
            # Проверяем, является ли ошибка "File is too big"
            if "File is too big" in str(e) and TELETHON_WORKER_CHAT_ID != 0:
                logger.info(f"Файл слишком большой для прямой загрузки, отправляю запрос телетон-воркеру")
                
                # Обновляем статус
                await status_message.edit_text(
                    "Видео слишком большое для прямой загрузки. Использую телетон-воркер... *сосредоточенно стучит по клавиатуре*"
                )
                
                try:
                    # Формируем команду
                    command_text = f"#video_download_{chat_id}_{message_id}"
                    logger.info(f"Отправляю команду в релейный чат: {command_text}, chat_id={TELETHON_WORKER_CHAT_ID}")
                    
                    # Отправляем видео с командой в релейный чат
                    # Вместо двух отдельных сообщений (команды и пересылки) отправляем видео с текстом команды
                    await context.bot.copy_message(
                        chat_id=TELETHON_WORKER_CHAT_ID,
                        from_chat_id=chat_id,
                        message_id=message_id,
                        caption=command_text  # Устанавливаем текст команды как подпись к видео
                    )
                    
                    # Обновляем статус
                    await status_message.edit_text(
                        "Запрос на скачивание отправлен! Ожидаю ответа... *нетерпеливо постукивает лапкой*"
                    )
                    
                except Exception as relay_error:
                    logger.error(f"Ошибка при отправке запроса воркеру: {relay_error}")
                    await status_message.edit_text(
                        f"Произошла ошибка при обработке видео через релейный чат: {str(relay_error)} *смущенно прячет мордочку*"
                    )
        else:
                await status_message.edit_text(
                    f"Произошла ошибка при скачивании видео: {str(e)} *испуганно прячется*"
                )
    
    # В минимальном режиме просто отвечаем текстом
    else:
        await update.message.reply_text(
            "Мяу! *игриво смотрит* Отправь мне видео, и я создам текстовую расшифровку! *виляет хвостиком*"
        )

def main() -> None:
    """Главная функция для запуска бота."""
    logger.info("Запуск бота...")
    
    # Инициализация бота
    application = ApplicationBuilder().token(BOT_TOKEN).build()

    # Обработчики команд
    application.add_handler(CommandHandler("start", start_command))
    application.add_handler(CommandHandler("help", help_command))
    application.add_handler(CommandHandler("status", status_command))
    application.add_handler(CommandHandler("rawtranscript", raw_transcript_command))
    
    # Обработчик для всех типов сообщений
    application.add_handler(MessageHandler(filters.ALL & ~filters.COMMAND, handle_message))
    
    # Обработчик для кнопок
    application.add_handler(CallbackQueryHandler(button_callback))

    # Запуск бота
    logger.info("Бот запущен и слушает сообщения...")
    application.run_polling(allowed_updates=Update.ALL_TYPES, drop_pending_updates=True)

if __name__ == '__main__':
    main()


